'use strict';

const path = require('path');
const assert = require('assert');
require('colors');

// Ensure testing is done in testing environment.
if (require(path.resolve(__dirname, '..', '..', '..', 'index')) !== 'hPfYDvYxb6srd2a0ixzjqQi1IchENnOU')
	throw 'Testing must be done in the testing environment that is provided in the repo: https://github.com/jkeveren/require-object'.red;

console.log('Testing environment found. Continuing with tests.'.green);

// require-object prevents this silly syntax.
const projectRoot = require(path.resolve('lib', 'project-root'));
const dirStructure = require(path.resolve('lib', 'directory-structure-to-object'));
const tokenize = require(path.resolve('lib', 'tokenize'));
const camelCase = require(path.resolve('lib', 'camel-case'));

describe('folder structure dependent', () => {

	describe('project-root.js', () => {

		it('returns correct project root path', () => {

			assert.equal(
				projectRoot,
				path.resolve(__dirname, '..', '..', '..')
			);

		});

	});


	describe('directory-structure-to-object.js', () => {

		/* These tests are why the test environment with a known
		folder structure must be used. */

		const dirObj = dirStructure(projectRoot);

		it('returns correct value of module.exports from .js file', () => {

			assert.equal(dirObj['test-files']['js-file.js'], true);

		});

		it('returns type Object from .json file', () => {

			assert.equal(typeof dirObj['test-files']['json-file.json'], 'object');

		});

		it('returns correct object from .json file', () => {

			const expected = {
				working: true
			}

			assert.deepEqual(dirObj['test-files']['json-file.json'], expected);

		});

		it('returns a buffer from non-js/json files', () => {

			assert.ok(dirObj['test-files']['text-file.txt'] instanceof Buffer);

		});

		it('returns correct buffer from non-js/json files', () => {

			const expected = 'This is a string in a text file.\n';

			assert.equal(dirObj['test-files']['text-file.txt'].toString(), expected);

		});

		describe('aliasing', () => {

			it('aliases file names in camelCase', () => {

				assert.equal(dirObj['test-files'].textFileTxt.toString(), dirObj['test-files']['text-file.txt'].toString());

			});

			it('alises conflicting punctuation with alphabetical priority', () => {

				assert.equal(dirObj['test-files'].conflicting.fileFile.toString(), 'file-file\n');

			});

		});

	});

});


describe('tokenize.js', () => {

	it('returns an array', () => {

		assert.ok(tokenize('testPhrase') instanceof Array);

	});

	it('tokenizes kebab-case', () => {

		assert.deepEqual(tokenize('kebab-case'), ['kebab', 'case']);

	});

	it('tokenizes snake_case', () => {

		assert.deepEqual(tokenize('snake_case'), ['snake', 'case']);

	});

	it('tokenizes TitleCase', () => {

		assert.deepEqual(tokenize('TitleCase'), ['title', 'case']);

	});

	it('tokenizes camelCase', () => {

		assert.deepEqual(tokenize('camelCase'), ['camel', 'case']);

	});

	it('tokenizes strings with preceding non word chars', () => {

		assert.deepEqual(tokenize('.precedingdot'), ['precedingdot']);

	});

});


describe('camel-case.js', () => {

	it('returns a string', () => {

		assert.equal(typeof camelCase(['foo']), 'string');

	});

	it('converts tokens to camelCase', () => {

		assert.equal(camelCase(['foo', 'bar', 'baz']), 'fooBarBaz');

	});

});
