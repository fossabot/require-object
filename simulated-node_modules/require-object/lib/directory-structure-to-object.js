'use strict';

const path = require('path');
const fs = require('fs');
const tokenize = require(path.resolve(__dirname, 'tokenize'));
const camelCase = require(path.resolve(__dirname, 'camel-case'));

module.exports = startPath => {

	// Final directory structure object to be returned
	let dirObject = {};

	// Recursive funtion that populates dirObject
	const recurse = (dirPath, parent) => {

		let items = fs.readdirSync(dirPath).sort((a, b) => {
			return a.toLowerCase() > b.toLowerCase();
		});

		// Iterates over all items in dirPath
		items.forEach((itemName) => {

			// Skip cirtain items
			if (['node_modules', '.git'].includes(itemName)) return;

			// Path to the item including the item itself
			const itemPath = path.resolve(dirPath, itemName);

			// Item information
			const stat = fs.statSync(itemPath);

			if (stat.isFile()) {

				// If file, add getter to parent
				const define = (name) => Object.defineProperty(parent, name, {

					/* If file extention is 'js' or 'json'
					require() the file, else read the file as a
					buffer. */
					get: () => /\.js(on)?$/.test(itemName) ? require(itemPath) : fs.readFileSync(path.resolve(itemPath)),

					enumerable: true

				});

				define(itemName);

			} else if (stat.isDirectory()) {

				/* if directory, add object to parent and do it
				all again from inside that object. */
				parent[itemName] = {};

				recurse(itemPath, parent[itemName]);

			}

		});

		// Aliasing (alphabetical priority)
		Object.keys(parent).sort((a, b) => a > b).forEach(itemName => {

			const alias = camelCase(tokenize(itemName));

			if (typeof parent[alias] === 'undefined') {
				const descriptor = Object.getOwnPropertyDescriptor(parent, itemName);
				descriptor.enumerable = false;
				Object.defineProperty(parent, alias, descriptor);
			}
		});

	}

	/* Start the recursion at startPath and the top level of
	dirObject (that is currently empty). */
	recurse(startPath, dirObject);

	// Return populated object
	return dirObject;

}
